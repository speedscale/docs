---
title: Optional Sidecar Annotations
---

import SidecarAnnotations from '../../../reference/_sidecar-annotations.mdx'

How to customize your sidecar configuration with annotations.

Here are additional annotation values for the sidecar:

<SidecarAnnotations />


### TLS Inbound Interception

The sidecar will be listening for incoming transactions, and must present to the client the correct certificate. Because you already have TLS configured, the cert files you are using must be provided to the sidecar. There are the fields:

* &#x20;**tlsinsecret** (required) is the name of the Kubernetes secret
* &#x20;**tlsinprivate** (optional) is the filename of the private key inside the secret (default: tls.key)
* &#x20;**tlsinpublic** (optional) is the filename of the public cert inside the secret (default: tls.crt)

When your deployment is injected, the sidecar will have an extra environment variable **TLS_IN_UNWRAP=true**, **TLS_IN_PUBLIC_KEY**, **TLS_IN_PRIVATE_KEY** and a volume mount to access the files from the provided secret.

```
  annotations:
    sidecar.speedscale.com/inject: "true"
    sidecar.speedscale.com/tls-out: "true"
    sidecar.speedscale.com/tls-in-secret: "my-tls-secret"
    sidecar.speedscale.com/tls-in-private: "tls.key"
    sidecar.speedscale.com/tls-in-public: "tls.crt"
```

### TLS Outbound Interception

To unwrap outbound TLS calls there are multiple steps required:

* Configure the sidecar to enable outbound TLS interception
* Configure your application to trust the new TLS Certificates

When your deployment is injected, the sidecar will have an extra environment variable **TLS_OUT_UNWRAP=true** and a volume mount to access the files from the **speedscale-certs** secret. The operator will automatically create a secret named **speedscale-certs** and put into the namespace. All that is required is to add this annotation to your deployment:

```
  annotations:
    sidecar.speedscale.com/inject: "true"
    sidecar.speedscale.com/tls-out: "true"
```

### Mutual Authentication for Outbound Calls

If your backend system requires [**Mutual Authentication**](https://tools.ietf. Org/html/rfc8120) (aka Mutual TLS or 2-Way TLS), this requires configuring the sidecar with an additional X509 key pair. During the TLS handshake, the backend system will request a Client Certificate. This is the certificate that goproxy will present. There are the fields:

* &#x20;**tlsmutualsecret** (required) is the name of the Kubernetes secret
* &#x20;**tlsmutualprivate** (optional) is the filename of the private key inside the secret (default: tls.key)
* &#x20;**tlsmutualpublic** (optional) is the filename of the public cert inside the secret (default: tls.crt)

When your deployment is injected, the sidecar will have extra environment variables **TLS_MUTUAL_PUBLIC_KEY** and **TLS_MUTUAL_PRIVATE_KEY** and a volume mount to access the files from the provided secret. You must provide a Kubernetes secret that has the TLS private key and public cert. The name of the secret and the names of the files can be provided to **operator** to inject automatically.

```
  annotations:
    sidecar.speedscale.com/inject: "true"
    sidecar.speedscale.com/tls-out: "true"
    sidecar.speedscale.com/tls-mutual-secret: "my-tls-secret"
    sidecar.speedscale.com/tls-mutual-private: "tls.key"
    sidecar.speedscale.com/tls-mutual-public: "tls.crt"
```

####
